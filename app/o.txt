@main.route('/dashboard')
@login_required
def dashboard():
    # Carrega TODOS os assuntos do usuário ou compartilhados
    all_assuntos = Assunto.query.filter(
        or_(
            Assunto.user_id == current_user.id,
            Assunto.shared_with.any(id=current_user.id)
        )
    ).order_by(Assunto.sort_order, Assunto.nome_assunto).all()

    # Filtra para exibir:
    # - Assuntos que não estão concluídos (is_completed == False)
    # ou
    # - Assuntos concluídos mas que possuem pelo menos uma tarefa que não está concluída
    assuntos = []
    for assunto in all_assuntos:
        if not assunto.is_completed:
            assuntos.append(assunto)
        else:
            # Se estiver concluído, verifica se existe pelo menos uma tarefa aberta
            if any(not tarefa.is_completed for tarefa in assunto.tarefas):
                assuntos.append(assunto)

    # Cria o dicionário para as tarefas visíveis para cada assunto
    assuntos_tarefas_visiveis = {}
    for assunto in assuntos:
        if assunto.shared_with.count() > 0:
            tarefas_visiveis = assunto.tarefas
        else:
            tarefas_visiveis = [tarefa for tarefa in assunto.tarefas if tarefa.user_id == current_user.id]
        assuntos_tarefas_visiveis[assunto.id] = tarefas_visiveis

    # Busca prazos pendentes (de acordo com sua lógica já existente)
    prazos = PrazoJudicial.query.filter(
        or_(
            PrazoJudicial.user_id == current_user.id,
            PrazoJudicial.shared_with.any(id=current_user.id)
        ),
        PrazoJudicial.status == False
    ).order_by(PrazoJudicial.prazo).all()

    current_date = date.today()
    tomorrow_date = current_date + timedelta(days=1)

    return render_template(
        'dashboard.html',
        assuntos=assuntos,
        assuntos_tarefas_visiveis=assuntos_tarefas_visiveis,
        prazos=prazos,
        current_date=current_date,
        tomorrow_date=tomorrow_date
    )

### ROTAS PARA ASSUNTOS, TAREFAS E PRAZOS (já existentes) ###
@main.route('/assunto/create', methods=['GET', 'POST'])
@login_required
@handle_db_errors
def create_assunto():
    form = AssuntoForm()
    if form.validate_on_submit():
        try:
            if form.client_existing.data:
                client_id = form.client_existing.data.id
            else:
                new_client = Client(
                    user_id=current_user.id,
                    name=form.client_new.data.strip()
                )
                db.session.add(new_client)
                db.session.commit()
                client_id = new_client.id
            novo = Assunto(
                user_id=current_user.id,
                client_id=client_id,
                nome_assunto=form.nome_assunto.data,
                due_date=form.due_date.data,
                sort_order=form.sort_order.data or 0
            )
            db.session.add(novo)
            db.session.commit()

            # LOG de histórico
            hist = AssuntoHistory(
                assunto_id=novo.id,
                change_type='created',
                changed_at=datetime.utcnow(),
                changed_by=current_user.id,
                snapshot=json.dumps({
                    'nome_assunto': novo.nome_assunto,
                    'due_date': str(novo.due_date) if novo.due_date else None,
                    'sort_order': novo.sort_order
                    # inclua o que julgar útil
                })
            )
            db.session.add(hist)
            db.session.commit()
            flash('Assunto criado com sucesso!', 'success')
            return redirect(url_for('main.dashboard'))
        except IntegrityError as e:
            db.session.rollback()
            if "UNIQUE constraint failed: clients.name" in str(e.orig):
                flash("Erro: O nome do cliente já está registrado. Por favor, escolha outro nome.", 'danger')
            else:
                flash(f"Erro ao criar assunto: {str(e)}", 'danger')
            current_app.logger.error(f'Erro ao criar assunto: {str(e)}')
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Erro ao criar assunto: {str(e)}')
            flash(f'Erro ao criar assunto: {str(e)}', 'danger')
    return render_template('create_assunto.html', form=form)

@main.route('/assunto/edit/<int:assunto_id>', methods=['GET', 'POST'])
@login_required
@handle_db_errors
def edit_assunto(assunto_id):
    assunto = Assunto.query.get_or_404(assunto_id)
    form = AssuntoForm(obj=assunto)
    form.client_existing.query = Client.query
    form.client_existing.data = assunto.client

    if form.validate_on_submit():
        try:
            # Capture os dados antigos
            old_data = {
                'nome_assunto': assunto.nome_assunto,
                'due_date': assunto.due_date.isoformat() if assunto.due_date else None,
                'sort_order': assunto.sort_order,
                'client_id': assunto.client_id
            }
            
            # Atualiza os dados
            assunto.nome_assunto = form.nome_assunto.data
            assunto.due_date = form.due_date.data
            assunto.sort_order = form.sort_order.data or 0
            if form.client_existing.data:
                assunto.client_id = form.client_existing.data.id
            else:
                new_client = Client(
                    user_id=current_user.id,
                    name=form.client_new.data.strip()
                )
                db.session.add(new_client)
                db.session.commit()
                assunto.client_id = new_client.id
            db.session.commit()
            
            # Capture os dados novos
            new_data = {
                'nome_assunto': assunto.nome_assunto,
                'due_date': assunto.due_date.isoformat() if assunto.due_date else None,
                'sort_order': assunto.sort_order,
                'client_id': assunto.client_id
            }
            
            # Calcule as diferenças
            diff = {}
            for key in old_data:
                if old_data[key] != new_data[key]:
                    diff[key] = {'old': old_data[key], 'new': new_data[key]}
            
            # Registre o histórico, se houver diferenças
            if diff:
                import json
                hist = AssuntoHistory(
                    assunto_id=assunto.id,
                    change_type='editado',
                    changed_by=current_user.id,
                    snapshot=json.dumps(diff)
                )
                db.session.add(hist)
                db.session.commit()
            
            flash('Assunto atualizado com sucesso e histórico registrado!', 'success')
            # ... notificações, etc. ...
            return redirect(url_for('main.dashboard'))
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Erro ao atualizar assunto: {str(e)}')
            flash(f'Erro ao atualizar assunto: {str(e)}', 'danger')


@main.route('/assunto/delete/<int:assunto_id>', methods=['POST'])
@login_required
def delete_assunto(assunto_id):
    assunto = Assunto.query.get_or_404(assunto_id)
    if assunto.user_id != current_user.id:
        flash("Não pode excluir assuntos de outros usuários.", "danger")
        return redirect(url_for('main.dashboard'))
    try:
        # Armazena a lista de usuários compartilhados antes de deletar
        shared_users = list(assunto.shared_with)
        db.session.execute(
            shared_assuntos.delete().where(shared_assuntos.c.assunto_id == assunto.id)
        )
        db.session.delete(assunto)
        db.session.commit()
        flash('Assunto excluído com sucesso!', 'success')

        for user in shared_users:
            if user.id != current_user.id:
                mensagem = f"{current_user.nickname} excluiu o assunto '{assunto.nome_assunto}'."
                criar_notificacao(user.id, "update", mensagem)
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Erro ao excluir assunto: {str(e)}')
        flash(f'Erro ao excluir assunto: {str(e)}', 'danger')
    return redirect(url_for('main.dashboard'))

@main.route('/assunto/toggle_status/<int:assunto_id>', methods=['POST'])
@login_required
def toggle_status_assunto(assunto_id):
    assunto = Assunto.query.get_or_404(assunto_id)
    try:
        assunto.is_completed = not assunto.is_completed
        if assunto.is_completed:
            assunto.data_conclusao = datetime.utcnow().date()
            assunto.completed_by = current_user.id
            acao = "concluído"
            # Marca todas as tarefas como concluídas também
            for tarefa in assunto.tarefas:
                tarefa.is_completed = True
                tarefa.data_conclusao = datetime.utcnow().date()
                tarefa.completed_by = current_user.id
        else:
            assunto.data_conclusao = None
            assunto.completed_by = None
            acao = "reaberto"
        db.session.commit()
        flash('Status do assunto atualizado!', 'success')
        
        # Notifica os envolvidos (criador e usuários partilhados, exceto o atual)
        envolvidos = set()
        envolvidos.add(assunto.user)
        envolvidos.update(assunto.shared_with.all() if hasattr(assunto.shared_with, 'all') else assunto.shared_with)
        for user in envolvidos:
            if user.id != current_user.id:
                mensagem = f"{current_user.nickname} marcou o assunto '{assunto.nome_assunto}' como {acao}."
                link = url_for('main.assunto_info', assunto_id=assunto.id) if 'assunto_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
                criar_notificacao(user.id, "update", mensagem, link)
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Erro ao alterar status do assunto: {str(e)}')
        flash(f'Erro ao alterar status do assunto: {str(e)}', 'danger')
    return redirect(url_for('main.dashboard'))


@main.route('/tarefa/create/<int:assunto_id>', methods=['GET', 'POST'])
@login_required
def create_tarefa(assunto_id):
    assunto = Assunto.query.get_or_404(assunto_id)
    form = TarefaForm()
    if form.validate_on_submit():
        try:
            nova = Tarefa(
                user_id=current_user.id,
                assunto_id=assunto.id,
                nome_tarefa=form.nome_tarefa.data,
                descricao=form.descricao.data or '',
                due_date=form.due_date.data,
                sort_order=form.sort_order.data or 0,
                horas=form.horas.data or 0.0,
                is_completed=False
            )
            db.session.add(nova)
            db.session.commit()
            flash('Tarefa criada com sucesso!', 'success')

            # Define o conjunto de usuários envolvidos:
            # Inclui o criador do assunto e todos os usuários compartilhados.
            envolvidos = set()
            envolvidos.add(assunto.user)
            envolvidos.update(assunto.shared_with)
            
            # Envia notificação para todos os envolvidos, exceto quem criou a tarefa.
            for user in envolvidos:
                if user.id != current_user.id:
                    mensagem = f"{current_user.nickname} criou a nova tarefa '{nova.nome_tarefa}' no assunto '{assunto.nome_assunto}'."
                    link = url_for('main.tarefa_info', tarefa_id=nova.id) if 'tarefa_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
                    criar_notificacao(user.id, "update", mensagem, link)
            
            return redirect(url_for('main.dashboard'))
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Erro ao criar tarefa: {str(e)}')
            flash(f'Erro ao criar tarefa: {str(e)}', 'danger')
    return render_template('create_tarefa.html', form=form, assunto=assunto)

@main.route('/tarefa/edit/<int:tarefa_id>', methods=['GET', 'POST'])
@login_required
@handle_db_errors
def edit_tarefa(tarefa_id):
    tarefa = Tarefa.query.get_or_404(tarefa_id)
    form = TarefaForm(obj=tarefa)
    if form.validate_on_submit():
        try:
            tarefa.nome_tarefa = form.nome_tarefa.data
            tarefa.descricao = form.descricao.data
            tarefa.due_date = form.due_date.data
            tarefa.sort_order = form.sort_order.data or 0
            tarefa.horas = form.horas.data or 0.0
            db.session.commit()
            flash('Tarefa atualizada com sucesso!', 'success')
            
            # Define os usuários envolvidos: criador da tarefa e usuários compartilhados do assunto
            envolvidos = set()
            envolvidos.add(tarefa.user)
            envolvidos.update(tarefa.assunto.shared_with)
            for user in envolvidos:
                if user.id != current_user.id:
                    mensagem = f"{current_user.nickname} editou a tarefa '{tarefa.nome_tarefa}'."
                    link = url_for('main.tarefa_info', tarefa_id=tarefa.id) if 'tarefa_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
                    criar_notificacao(user.id, "update", mensagem, link)
                    
            return redirect(url_for('main.dashboard'))
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Erro ao atualizar tarefa: {str(e)}')
            flash(f'Erro ao atualizar tarefa: {str(e)}', 'danger')
    return render_template('edit_tarefa.html', form=form, tarefa=tarefa)


@main.route('/tarefa/delete/<int:tarefa_id>', methods=['POST'])
@login_required
def delete_tarefa(tarefa_id):
    tarefa = Tarefa.query.get_or_404(tarefa_id)
    if tarefa.user_id != current_user.id:
        flash("Não pode excluir tarefas de outros usuários.", "danger")
        return redirect(url_for('main.dashboard'))
    # Notifica os usuários antes da exclusão
    for user in tarefa.assunto.shared_with:
        if user.id != current_user.id:
            mensagem = f"{current_user.nickname} excluiu a tarefa '{tarefa.nome_tarefa}'."
            criar_notificacao(user.id, "update", mensagem)
    try:
        db.session.delete(tarefa)
        db.session.commit()
        flash('Tarefa excluída com sucesso!', 'success')
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Erro ao excluir tarefa: {str(e)}')
        flash(f'Erro ao excluir tarefa: {str(e)}', 'danger')
    return redirect(url_for('main.dashboard'))

@main.route('/tarefa/add_hours/<int:tarefa_id>', methods=['POST'])
@login_required
def add_hours_tarefa(tarefa_id):
    tarefa = Tarefa.query.get_or_404(tarefa_id)
    try:
        horas = float(request.form.get('horas', 0))
        tarefa.horas += horas
        registro = HoraAdicao(
            item_type='tarefa',
            item_id=tarefa.id,
            horas_adicionadas=horas,
            user_id=current_user.id
        )
        db.session.add(registro)
        db.session.commit()
        flash("Horas adicionadas com sucesso!", "success")
        
        # Cria um conjunto para unificar os usuários a serem notificados
        notificados = set()
        # Adiciona os usuários compartilhados no assunto
        assunto_users = tarefa.assunto.shared_with.all() if hasattr(tarefa.assunto.shared_with, 'all') else tarefa.assunto.shared_with
        for user in assunto_users:
            notificados.add(user)
        # Além disso, inclua o criador do assunto, se não for o usuário atual
        if tarefa.assunto.user_id != current_user.id:
            # Obtenha o usuário criador do assunto (ADM)
            notificados.add(tarefa.assunto.user)
        
        # Remova o usuário que está adicionando as horas (ADV)
        notificados = [user for user in notificados if user.id != current_user.id]

        for user in notificados:
            mensagem = f"{current_user.nickname} adicionou {horas}h na tarefa '{tarefa.nome_tarefa}'."
            link = url_for('main.tarefa_info', tarefa_id=tarefa.id) if 'tarefa_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
            criar_notificacao(user.id, "update", mensagem, link)
                
    except Exception as e:
        db.session.rollback()
        flash(f"Erro ao adicionar horas: {str(e)}", "danger")
    return redirect(url_for('main.dashboard'))


@main.route('/tarefa/toggle_status/<int:tarefa_id>', methods=['POST'])
@login_required
def toggle_status_tarefa(tarefa_id):
    tarefa = Tarefa.query.get_or_404(tarefa_id)
    try:
        tarefa.is_completed = not tarefa.is_completed
        if tarefa.is_completed:
            tarefa.data_conclusao = datetime.utcnow().date()
            tarefa.completed_by = current_user.id
            acao = "concluída"
        else:
            tarefa.data_conclusao = None
            tarefa.completed_by = None
            acao = "reaberta"
        db.session.commit()
        flash('Status da tarefa atualizado!', 'success')
        
        notificados = set()
        # Adiciona os usuários compartilhados do assunto
        assunto_users = tarefa.assunto.shared_with.all() if hasattr(tarefa.assunto.shared_with, 'all') else tarefa.assunto.shared_with
        for user in assunto_users:
            notificados.add(user)
        # Adiciona o dono do assunto
        notificados.add(tarefa.assunto.user)
        # Remove o usuário que executou a ação
        notificados = [user for user in notificados if user.id != current_user.id]
        
        for user in notificados:
            mensagem = f"{current_user.nickname} marcou a tarefa '{tarefa.nome_tarefa}' como {acao}."
            link = url_for('main.tarefa_info', tarefa_id=tarefa.id) if 'tarefa_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
            criar_notificacao(user.id, "update", mensagem, link)
            
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Erro ao alterar status da tarefa: {str(e)}')
        flash(f'Erro ao alterar status da tarefa: {str(e)}', 'danger')
    return redirect(url_for('main.dashboard'))


@main.route('/prazos/create', methods=['GET', 'POST'])
@login_required
def create_prazo():
    form = PrazoJudicialForm()
    if form.is_submitted() and not form.validate():
        print("Erros do formulário de prazo:", form.errors)
    if form.validate_on_submit():
        try:
            if form.client_existing.data:
                client_id = form.client_existing.data.id
            else:
                new_client = Client(
                    user_id=current_user.id,  # Adicionado aqui
                    name=form.client_new.data.strip()
                 )
                db.session.add(new_client)
                db.session.commit()
                client_id = new_client.id
            novo = PrazoJudicial(
                user_id=current_user.id,
                client_id=client_id,
                assunto=form.assunto.data,
                processo=form.processo.data,
                prazo=form.prazo.data,
                comentarios=form.comentarios.data or ''
            )
            if form.shared_with.data:
                novo.shared_with = form.shared_with.data

            db.session.add(novo)
            db.session.commit()
            flash('Prazo criado com sucesso!', 'success')
            return redirect(url_for('main.dashboard'))
        except IntegrityError as e:
            db.session.rollback()
            # Verifica se o erro se refere à constraint UNIQUE do nome do cliente
            if "UNIQUE constraint failed: clients.name" in str(e.orig):
                flash("Erro: O nome do cliente já está registrado. Por favor, escolha outro nome.", 'danger')
            else:
                flash(f"Erro ao criar prazo: {str(e)}", 'danger')
            current_app.logger.error(f'Erro ao criar prazo: {str(e)}')
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Erro ao criar prazo: {str(e)}')
            flash(f'Erro ao criar prazo: {str(e)}', 'danger')
    return render_template('prazos_judiciais.html', form=form)

@main.route('/prazo/edit/<int:prazo_id>', methods=['GET', 'POST'])
@login_required
def edit_prazo(prazo_id):
    prazo = PrazoJudicial.query.get_or_404(prazo_id)
    old_shared = list(prazo.shared_with)  # Se necessário para comparação ou para notificações
    form = PrazoJudicialForm(obj=prazo)
    form.client_existing.query = Client.query
    form.client_existing.data = prazo.client
    if form.validate_on_submit():
        try:
            if form.client_existing.data:
                prazo.client_id = form.client_existing.data.id
            else:
                new_client = Client(
                    user_id=current_user.id,
                    name=form.client_new.data.strip()
                )
                db.session.add(new_client)
                db.session.commit()
                prazo.client_id = new_client.id

            prazo.assunto = form.assunto.data
            prazo.processo = form.processo.data
            prazo.prazo = form.prazo.data
            prazo.comentarios = form.comentarios.data or ''
            
            # Atualiza o compartilhamento sem remover os já existentes
            if current_user.id == prazo.user_id:
                # Se o editor é o criador, preserva os compartilhamentos já existentes e adiciona os novos
                prazo.shared_with = list(set(prazo.shared_with).union(set(form.shared_with.data)))
            else:
                # Se o editor não é o criador, utiliza os dados do formulário,
                # mas garante que o próprio usuário que está editando continue na partilha
                prazo.shared_with = form.shared_with.data
                if current_user not in prazo.shared_with:
                    prazo.shared_with.append(current_user)
            
            prazo.horas = form.horas.data or 0.0
            db.session.commit()
            flash('Prazo atualizado com sucesso!', 'success')

            # Notifica todos os envolvidos: criador + todos os usuários compartilhados
            envolvidos = set()
            envolvidos.add(prazo.user)
            envolvidos.update(prazo.shared_with)
            for user in envolvidos:
                if user.id != current_user.id:
                    mensagem = f"{current_user.nickname} editou o prazo '{prazo.assunto}' (Processo: {prazo.processo})."
                    link = url_for('main.prazo_info', prazo_id=prazo.id) if 'prazo_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
                    criar_notificacao(user.id, "update", mensagem, link)
            return redirect(url_for('main.dashboard'))
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Erro ao atualizar prazo: {str(e)}')
            flash(f'Erro ao atualizar prazo: {str(e)}', 'danger')
    return render_template('edit_prazo.html', form=form, prazo=prazo)


@main.route('/prazo/delete/<int:prazo_id>', methods=['POST'])
@login_required
def delete_prazo(prazo_id):
    prazo = PrazoJudicial.query.get_or_404(prazo_id)
    if prazo.user_id != current_user.id:
        flash("Não pode excluir prazos de outros usuários.", "danger")
        return redirect(url_for('main.dashboard'))
    try:
        # Armazena os usuários compartilhados antes de deletar
        shared_users = list(prazo.shared_with)
        db.session.execute(
            shared_prazos.delete().where(shared_prazos.c.prazo_id == prazo.id)
        )
        db.session.delete(prazo)
        db.session.commit()
        flash('Prazo excluído com sucesso!', 'success')

        for user in shared_users:
            if user.id != current_user.id:
                mensagem = f"{current_user.nickname} excluiu o prazo '{prazo.assunto}' (Processo: {prazo.processo})."
                criar_notificacao(user.id, "update", mensagem)
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Erro ao excluir prazo: {str(e)}')
        flash(f'Erro ao excluir prazo: {str(e)}', 'danger')
    return redirect(url_for('main.dashboard'))


@main.route('/prazo/add_hours/<int:prazo_id>', methods=['POST'])
@login_required
def add_hours_prazo(prazo_id):
    prazo = PrazoJudicial.query.get_or_404(prazo_id)
    try:
        horas = float(request.form.get('horas', 0))
        prazo.horas += horas
        registro = HoraAdicao(
            item_type='prazo',
            item_id=prazo.id,
            horas_adicionadas=horas,
            user_id=current_user.id
        )
        db.session.add(registro)
        db.session.commit()
        flash("Horas adicionadas com sucesso!", "success")
        
        # Cria um conjunto para unificar os usuários a serem notificados
        notificados = set()
        # Adiciona os usuários explicitamente compartilhados no prazo
        prazo_users = prazo.shared_with.all() if hasattr(prazo.shared_with, 'all') else prazo.shared_with
        for user in prazo_users:
            notificados.add(user)
        # Inclui o criador do prazo (ADM) mesmo que não esteja na lista de compartilhamento
        if prazo.user_id != current_user.id:
            notificados.add(prazo.user)
        
        # Remove o usuário que está adicionando as horas (ADV)
        notificados = [user for user in notificados if user.id != current_user.id]
        
        for user in notificados:
            mensagem = f"{current_user.nickname} adicionou {horas}h ao prazo '{prazo.assunto}' (Processo: {prazo.processo})."
            link = url_for('main.prazo_info', prazo_id=prazo.id) if 'prazo_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
            criar_notificacao(user.id, "update", mensagem, link)
                
    except Exception as e:
        db.session.rollback()
        flash(f"Erro ao adicionar horas: {str(e)}", "danger")
    return redirect(url_for('main.dashboard'))

@main.route('/prazo/toggle_status/<int:prazo_id>', methods=['POST'])
@login_required
def toggle_status_prazo(prazo_id):
    prazo = PrazoJudicial.query.get_or_404(prazo_id)
    try:
        prazo.status = not prazo.status
        if prazo.status:
            prazo.data_conclusao = datetime.utcnow().date()
            prazo.completed_by = current_user.id
            acao = "concluído"
        else:
            prazo.data_conclusao = None
            prazo.completed_by = None
            acao = "reaberto"
        db.session.commit()
        flash('Status do prazo atualizado!', 'success')
        
        # Unir usuários a notificar: usuários compartilhados no prazo e o dono do prazo
        notificados = set()
        prazo_users = prazo.shared_with.all() if hasattr(prazo.shared_with, 'all') else prazo.shared_with
        for user in prazo_users:
            notificados.add(user)
        # Adiciona o criador do prazo
        notificados.add(prazo.user)
        # Remove o usuário atual
        notificados = [user for user in notificados if user.id != current_user.id]
        
        for user in notificados:
            mensagem = f"{current_user.nickname} marcou o prazo '{prazo.assunto}' como {acao}."
            link = url_for('main.prazo_info', prazo_id=prazo.id) if 'prazo_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
            criar_notificacao(user.id, "update", mensagem, link)
            
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'Erro ao alterar status do prazo: {str(e)}')
        flash(f'Erro ao alterar status do prazo: {str(e)}', 'danger')
    return redirect(url_for('main.dashboard'))

# Rotas para compartilhar assuntos e prazos

@main.route('/assunto/share/<int:assunto_id>', methods=['GET', 'POST'])
@login_required
def share_assunto(assunto_id):
    assunto = Assunto.query.get_or_404(assunto_id)
    if assunto.user_id != current_user.id:
        flash("Não pode compartilhar assuntos de outros usuários.", "danger")
        return redirect(url_for('main.dashboard'))
    form = ShareForm(obj=assunto)
    if form.validate_on_submit():
        # Obtém os usuários com quem o assunto será compartilhado
        novos_usuarios = form.shared_with.data
        assunto.shared_with = novos_usuarios

        db.session.commit()
        flash("Assunto e todas as tarefas associadas foram compartilhados com sucesso!", "success")
        
        # Gera notificações para os usuários (exceto o usuário atual)
        for user in novos_usuarios:
            if user.id != current_user.id:
                mensagem = f"{current_user.nickname} partilhou consigo o assunto {assunto.nome_assunto}"
                # Ajuste a rota do link conforme a sua aplicação (por exemplo, para ver detalhes do assunto)
                link = url_for('main.assunto_info', assunto_id=assunto.id) if 'assunto_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
                criar_notificacao(user.id, "share_invite", mensagem, link)
        
        return redirect(url_for('main.dashboard'))
    return render_template('share_assunto.html', form=form, assunto=assunto)


@main.route('/prazo/share/<int:prazo_id>', methods=['GET', 'POST'])
@login_required
def share_prazo(prazo_id):
    prazo = PrazoJudicial.query.get_or_404(prazo_id)
    if prazo.user_id != current_user.id:
        flash("Não pode compartilhar prazos de outro usuário.", "danger")
        return redirect(url_for('main.dashboard'))
    form = ShareForm(obj=prazo)
    if form.validate_on_submit():
        novos_usuarios = form.shared_with.data
        prazo.shared_with = novos_usuarios
        db.session.commit()
        flash("Prazo compartilhado com sucesso!", "success")
        
        # Gera notificações para os usuários (exceto o usuário atual)
        for user in novos_usuarios:
            if user.id != current_user.id:
                mensagem = f"{current_user.nickname} partilhou consigo o prazo '{prazo.assunto}' (Processo: {prazo.processo})."
                link = url_for('main.prazo_info', prazo_id=prazo.id) if 'prazo_info' in current_app.jinja_env.list_templates() else url_for('main.dashboard')
                criar_notificacao(user.id, "share_invite", mensagem, link)
        
        return redirect(url_for('main.dashboard'))
    return render_template('share_prazo.html', form=form, prazo=prazo)

### ROTA PARA GUARDAR REORGANIZAÇÃO DOS ASSUNTOS NO DASHBOARD

@main.route('/update_assuntos_order', methods=['POST'])
@login_required
def update_assuntos_order():
    data = request.get_json()
    if not data or 'ordem' not in data:
        return jsonify({'status': 'error', 'message': 'Dados inválidos'}), 400
    
    ordem = data['ordem']
    try:
        for item in ordem:
            assunto_id = int(item['id'])
            new_order = int(item['sort_order'])
            assunto = Assunto.query.get(assunto_id)
            # Log para depuração
            current_app.logger.info(f"Tentando atualizar assunto {assunto_id} para ordem {new_order}")
            if assunto and assunto.user_id == current_user.id:
                assunto.sort_order = new_order
                current_app.logger.info(f"Assunto {assunto_id} atualizado com nova ordem {new_order}")
            else:
                current_app.logger.warning(f"Assunto {assunto_id} não encontrado ou não pertence ao usuário {current_user.id}")
        db.session.commit()
        return jsonify({'status': 'ok'})
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Erro ao atualizar ordem: {str(e)}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

#END ROTAS ASSUNTOS, TAREFAS E PRAZOS

#BEGIN ROTAS PARA HISTÓRICO DE ASSUNTOS, TAREFAS, PRAZOS
@main.route('/history/assunto/<int:assunto_id>')
@login_required
def history_assunto(assunto_id):
    assunto = Assunto.query.get_or_404(assunto_id)
    # Histórico de alterações do assunto
    assunto_history = AssuntoHistory.query.filter_by(assunto_id=assunto_id)\
                                          .order_by(AssuntoHistory.changed_at.desc())\
                                          .all()
    
    # Monta o dicionário de histórico para cada tarefa associada
    tasks_history = {}
    # Se sua relação for dinâmica (lazy='dynamic'), use .all()
    # Caso contrário, se já for uma lista, apenas itere sobre assunto.tarefas
    for tarefa in assunto.tarefas.all():
        tarefa_history = TarefaHistory.query.filter_by(tarefa_id=tarefa.id)\
                                            .order_by(TarefaHistory.changed_at.desc())\
                                            .all()
        tasks_history[tarefa.id] = tarefa_history

    # Comentários associados ao assunto
    comments = Comment.query.filter_by(object_type='assunto', object_id=assunto_id)\
                            .order_by(Comment.created_at.desc())\
                            .all()
    # Instancia o formulário de comentário
    form = CommentForm()
    
    # Passe tasks_history no contexto!
    return render_template('history_assunto.html',
                           assunto=assunto,
                           history_entries=assunto_history,
                           tasks_history=tasks_history,
                           comments=comments,
                           form=form)


@main.route('/add_comment', methods=['POST'])
@login_required
def add_comment():
    object_type = request.form.get('object_type')
    object_id = request.form.get('object_id')
    comment_text = request.form.get('comment_text')
    if object_type and object_id and comment_text:
        comment = Comment(
            object_type=object_type,
            object_id=int(object_id),
            user_id=current_user.id,
            comment_text=comment_text
        )
        db.session.add(comment)
        db.session.commit()
        flash("Comentário adicionado.", "success")
    else:
        flash("Preencha todos os dados.", "danger")
    # Redirecione de volta para a página de histórico de acordo com o objeto
    if object_type == 'assunto':
        return redirect(url_for('main.history_assunto', assunto_id=object_id))
    # Adicione redirecionamento para outras entidades se necessário
    return redirect(url_for('dashboard'))
#END ROTAS PARA HISTÓRICO DE ASSUNTOS, TAREFAS, PRAZOS

''''''''''''''
'''''''''''''''''
''''''''''''''''
''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
MODELS.PY

#BEGIN MODEL AUDITORIA
# Log de Auditoria
class AuditLog(db.Model):
    __tablename__ = 'audit_logs'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'))
    action = db.Column(db.String(200))
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    details = db.Column(db.Text, nullable=True)
    
    def __repr__(self):
        return f'<AuditLog {self.action} by {self.user_id} at {self.timestamp}>'
#END MODEL AUDITORIA

#BEGIN MODEL ASSUNTO
class Assunto(db.Model):
    __tablename__ = 'assuntos'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)  # Dono
    client_id = db.Column(db.Integer, db.ForeignKey('clients.id'), nullable=False)
    nome_assunto = db.Column(db.String(100), nullable=False)
    due_date = db.Column(db.Date, nullable=True)
    sort_order = db.Column(db.Integer, default=0)
    horas_assunto = db.Column(db.Float, default=0.0)
    is_completed = db.Column(db.Boolean, default=False)
    is_billed = db.Column(db.Boolean, default=False)
    completed_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)

    tarefas = db.relationship('Tarefa', backref='assunto', cascade="all, delete-orphan", lazy='dynamic')
    shared_with = db.relationship(
        'User',
        secondary=shared_assuntos,
        backref=db.backref('shared_assuntos', lazy='dynamic', overlaps="assuntos_compartilhados,compartilhados"),
        lazy='dynamic',
        overlaps="assuntos_compartilhados,compartilhados"
    )

    # RELACIONAMENTO PARA ACESSAR O DONO – certifique-se de que ESTÁ indentado dentro da classe
    user = db.relationship("User", backref="assuntos_criados", foreign_keys=lambda: [Assunto.__table__.c.user_id])

    def __repr__(self):
        return f'<Assunto {self.client.name} - {self.nome_assunto}>'
#END MODEL ASSUNTO

#BEGIN MODEL TAREFA
class Tarefa(db.Model):
    __tablename__ = 'tarefas'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    assunto_id = db.Column(db.Integer, db.ForeignKey('assuntos.id'), nullable=False)
    nome_tarefa = db.Column(db.String(100), nullable=False)
    descricao = db.Column(db.String(200), nullable=True)
    due_date = db.Column(db.Date, nullable=True)
    sort_order = db.Column(db.Integer, default=0)
    is_completed = db.Column(db.Boolean, default=False)
    horas = db.Column(db.Float, default=0.0)
    is_billed = db.Column(db.Boolean, default=False)
    data_conclusao = db.Column(db.Date, nullable=True)
    completed_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)

    user = db.relationship("User", backref="tarefas_criadas", foreign_keys=lambda: [Tarefa.__table__.c.user_id])

    def __repr__(self):
        return f'<Tarefa {self.nome_tarefa} (Assunto: {self.assunto.nome_assunto if self.assunto else "N/A"})>'

#END MODEL TAREFA

#BEGIN MODEL PRAZO
class PrazoJudicial(db.Model):
    __tablename__ = 'prazos_judiciais'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    client_id = db.Column(db.Integer, db.ForeignKey('clients.id'), nullable=False)
    assunto = db.Column(db.String(100), nullable=False)
    processo = db.Column(db.String(100), nullable=False)
    prazo = db.Column(db.Date, nullable=True)
    comentarios = db.Column(db.Text, nullable=True)
    status = db.Column(db.Boolean, default=False)
    horas = db.Column(db.Float, default=0.0)
    is_billed = db.Column(db.Boolean, default=False)
    data_conclusao = db.Column(db.Date, nullable=True)
    completed_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    client = db.relationship('Client', backref='prazos_judiciais')
    
    shared_with = db.relationship(
        'User',
        secondary=shared_prazos,
        backref=db.backref('shared_prazos', lazy='dynamic', overlaps="prazos_compartilhados,compartilhados"),
        lazy='dynamic',
        overlaps="prazos_compartilhados,compartilhados"
    )

    user = db.relationship("User", backref="prazos_criados", foreign_keys=lambda: [PrazoJudicial.__table__.c.user_id])

    def __repr__(self):
        return f'<PrazoJudicial {self.client.name} - {self.assunto}>'
#END MODEL PRAZO

#BEGIN MODEL HOUR ENTRY - TAREFAS, PRAZOS
# Hour Entry
class HourEntry(db.Model):
    __tablename__ = 'hour_entries'
    id = db.Column(db.Integer, primary_key=True)
    object_type = db.Column(db.String(20), nullable=False)  # 'tarefa' ou 'prazo'
    object_id = db.Column(db.Integer, nullable=False)
    hours = db.Column(db.Float, nullable=False)
    entry_date = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<HourEntry {self.object_type}:{self.object_id} - {self.hours}h em {self.entry_date}>'
#END MODEL HOUR ENTRY - TAREFAS, PRAZOS

#BEGIN MODEL HISTÓRICO DE CARDS DE ASSUNTOS, TAREFAS, PRAZOS
class AssuntoHistory(db.Model):
    __tablename__ = 'assuntos_history'
    id = db.Column(db.Integer, primary_key=True)
    assunto_id = db.Column(db.Integer, nullable=False)  # FK para o assunto original
    change_type = db.Column(db.String(20))  # 'created', 'updated', 'deleted'
    changed_at = db.Column(db.DateTime, default=datetime.utcnow)
    changed_by = db.Column(db.Integer, db.ForeignKey('users.id'))
    # Armazene as mudanças – pode ser um JSON com um snapshot ou somente os campos alterados
    snapshot = db.Column(db.JSON)  # Requer que seu banco suporte JSON

    def __repr__(self):
        return f"<Histórico Assunto {self.assunto_id} {self.change_type} em {self.changed_at}>"

class TarefaHistory(db.Model):
    __tablename__ = 'tarefas_history'
    id = db.Column(db.Integer, primary_key=True)
    tarefa_id = db.Column(db.Integer, nullable=False)  # FK para a tarefa
    change_type = db.Column(db.String(20), nullable=False)  # ex.: 'created', 'edited'
    changed_at = db.Column(db.DateTime, default=datetime.utcnow)
    changed_by = db.Column(db.Integer, db.ForeignKey('users.id'))
    snapshot = db.Column(db.JSON)  # ou db.Column(db.Text)

    def __repr__(self):
        return f"<TarefaHistory {self.tarefa_id} {self.change_type} em {self.changed_at}>"

class Comment(db.Model):
    __tablename__ = 'comments'
    id = db.Column(db.Integer, primary_key=True)
    object_type = db.Column(db.String(50))  # 'assunto', 'tarefa' ou 'prazo'
    object_id = db.Column(db.Integer, nullable=False)  # ID do assunto/tarefa/prazo
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    comment_text = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    user = db.relationship('User', backref='comments')

    def __repr__(self):
        return f"<Comment {self.id} em {self.object_type}:{self.object_id}>"
#END MODEL


''''''''''''''
'''''''''''''''''
''''''''''''''''
''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
TEMPLATES


{% extends "base.html" %}
{% block title %}Histórico do Assunto: {{ assunto.nome_assunto }}{% endblock %}
{% block content %}
<div class="container my-4">
  <h2>Histórico do Assunto: {{ assunto.nome_assunto }}</h2>
  
  <!-- Card com as Informações do Assunto -->
  <div class="card mb-3">
    <div class="card-header">
      Informações do Assunto
    </div>
    <div class="card-body">
      <p><strong>Cliente:</strong> {{ assunto.client.name }}</p>
      <p><strong>Criado em:</strong> 
         {% if assunto.created_at %}
           {{ assunto.created_at.strftime('%d/%m/%Y %H:%M') }}
         {% else %}
           N/A
         {% endif %}
      </p>
      {% if assunto.updated_at %}
      <p><strong>Última Atualização:</strong> {{ assunto.updated_at.strftime('%d/%m/%Y %H:%M') }}</p>
      {% endif %}
      <p><strong>Status:</strong> {% if assunto.is_completed %}Concluído{% else %}Aberto{% endif %}</p>
    </div>
  </div>
  
  <!-- Histórico de Edições do Assunto -->
  <div class="mb-3">
    <h3>Histórico de Edições do Assunto</h3>
    {% if assunto_history %}
      <ul class="list-group">
      {% for hist in assunto_history %}
        <li class="list-group-item">
          <strong>{{ hist.change_type|capitalize }}</strong>
          em {{ hist.changed_at.strftime('%d/%m/%Y %H:%M') }}
          por usuário ID {{ hist.changed_by }}
          {% if hist.snapshot %}
            <div>
              <small>Detalhes:</small>
              <pre>{{ hist.snapshot|tojson(indent=2) }}</pre>
            </div>
          {% endif %}
        </li>
      {% endfor %}
      </ul>
    {% else %}
      <p>Sem histórico de edições para este assunto.</p>
    {% endif %}
  </div>
  
  <!-- Histórico das Tarefas Associadas -->
  <div class="mb-3">
    <h3>Histórico das Tarefas Associadas</h3>
    {% if assunto.tarefas.count() > 0 %}
      {% for tarefa in assunto.tarefas.all() %}
        <div class="card mb-2">
          <div class="card-header">
            Tarefa: {{ tarefa.nome_tarefa }}
          </div>
          <div class="card-body">
            <p><strong>Horas:</strong> {{ tarefa.horas }}h</p>
            <p><strong>Status:</strong> {% if tarefa.is_completed %}Concluída{% else %}Aberta{% endif %}</p>
            <p><strong>Criada em:</strong> 
               {% if tarefa.created_at %}
                 {{ tarefa.created_at.strftime('%d/%m/%Y %H:%M') }}
               {% else %}
                 N/A
               {% endif %}
            </p>
            <!-- Histórico da Tarefa -->
            {% set tarefa_hist = tasks_history[tarefa.id] %}
            {% if tarefa_hist %}
              <h5>Histórico da Tarefa</h5>
              <ul class="list-group">
                {% for hist in tarefa_hist %}
                  <li class="list-group-item">
                    <strong>{{ hist.change_type|capitalize }}</strong>
                    em {{ hist.changed_at.strftime('%d/%m/%Y %H:%M') }}
                    por usuário ID {{ hist.changed_by }}
                    {% if hist.snapshot %}
                      <div>
                        <small>Detalhes:</small>
                        <pre>{{ hist.snapshot|tojson(indent=2) }}</pre>
                      </div>
                    {% endif %}
                  </li>
                {% endfor %}
              </ul>
            {% else %}
              <p>Sem histórico para esta tarefa.</p>
            {% endif %}
          </div>
        </div>
      {% endfor %}
    {% else %}
      <p>Sem tarefas associadas a este assunto.</p>
    {% endif %}
        
    <!-- Formulário para adicionar novo comentário -->
    <div class="mt-3">
      <form action="{{ url_for('main.add_comment') }}" method="POST">
        {{ form.hidden_tag() }}
        <input type="hidden" name="object_type" value="assunto">
        <input type="hidden" name="object_id" value="{{ assunto.id }}">
        <div class="mb-3">
          {{ form.comment_text.label(class="form-label") }}
          {{ form.comment_text(rows=3, class="form-control") }}
        </div>
        <button type="submit" class="btn btn-primary">{{ form.submit.label.text }}</button>
      </form>
    </div>
  </div>
  
</div>
{% endblock %}


{% extends "base.html" %}
{% block title %}Histórico do Assunto: {{ assunto.nome_assunto }}{% endblock %}
{% block content %}
<div class="container my-4">
  <h2>Histórico do Assunto: {{ assunto.nome_assunto }}</h2>
  
  <!-- Card com as Informações do Assunto -->
  <div class="card mb-3">
    <div class="card-header">
      Informações do Assunto
    </div>
    <div class="card-body">
      <p><strong>Cliente:</strong> {{ assunto.client.name }}</p>
      <p><strong>Criado em:</strong> 
         {% if assunto.created_at %}
           {{ assunto.created_at.strftime('%d/%m/%Y %H:%M') }}
         {% else %}
           N/A
         {% endif %}
      </p>
      {% if assunto.updated_at %}
      <p><strong>Última Atualização:</strong> {{ assunto.updated_at.strftime('%d/%m/%Y %H:%M') }}</p>
      {% endif %}
      <p><strong>Status:</strong> {% if assunto.is_completed %}Concluído{% else %}Aberto{% endif %}</p>
    </div>
  </div>
  
  <!-- Histórico de Edições do Assunto -->
  <div class="mb-3">
    <h3>Histórico de Edições do Assunto</h3>
    {% if assunto_history %}
      <ul class="list-group">
      {% for hist in assunto_history %}
        <li class="list-group-item">
          <strong>{{ hist.change_type|capitalize }}</strong>
          em {{ hist.changed_at.strftime('%d/%m/%Y %H:%M') }}
          por usuário ID {{ hist.changed_by }}
          {% if hist.snapshot %}
            <div>
              <small>Detalhes:</small>
              <pre>{{ hist.snapshot|tojson(indent=2) }}</pre>
            </div>
          {% endif %}
        </li>
      {% endfor %}
      </ul>
    {% else %}
      <p>Sem histórico de edições para este assunto.</p>
    {% endif %}
  </div>
  
  <!-- Histórico das Tarefas Associadas -->
  <div class="mb-3">
    <h3>Histórico das Tarefas Associadas</h3>
    {% if assunto.tarefas.count() > 0 %}
      {% for tarefa in assunto.tarefas.all() %}
        <div class="card mb-2">
          <div class="card-header">
            Tarefa: {{ tarefa.nome_tarefa }}
          </div>
          <div class="card-body">
            <p><strong>Horas:</strong> {{ tarefa.horas }}h</p>
            <p><strong>Status:</strong> {% if tarefa.is_completed %}Concluída{% else %}Aberta{% endif %}</p>
            <p><strong>Criada em:</strong> 
               {% if tarefa.created_at %}
                 {{ tarefa.created_at.strftime('%d/%m/%Y %H:%M') }}
               {% else %}
                 N/A
               {% endif %}
            </p>
            <!-- Histórico da Tarefa -->
            {% set tarefa_hist = tasks_history[tarefa.id] %}
            {% if tarefa_hist %}
              <h5>Histórico da Tarefa</h5>
              <ul class="list-group">
                {% for hist in tarefa_hist %}
                  <li class="list-group-item">
                    <strong>{{ hist.change_type|capitalize }}</strong>
                    em {{ hist.changed_at.strftime('%d/%m/%Y %H:%M') }}
                    por usuário ID {{ hist.changed_by }}
                    {% if hist.snapshot %}
                      <div>
                        <small>Detalhes:</small>
                        <pre>{{ hist.snapshot|tojson(indent=2) }}</pre>
                      </div>
                    {% endif %}
                  </li>
                {% endfor %}
              </ul>
            {% else %}
              <p>Sem histórico para esta tarefa.</p>
            {% endif %}
          </div>
        </div>
      {% endfor %}
    {% else %}
      <p>Sem tarefas associadas a este assunto.</p>
    {% endif %}
        
    <!-- Formulário para adicionar novo comentário -->
    <div class="mt-3">
      <form action="{{ url_for('main.add_comment') }}" method="POST">
        {{ form.hidden_tag() }}
        <input type="hidden" name="object_type" value="assunto">
        <input type="hidden" name="object_id" value="{{ assunto.id }}">
        <div class="mb-3">
          {{ form.comment_text.label(class="form-label") }}
          {{ form.comment_text(rows=3, class="form-control") }}
        </div>
        <button type="submit" class="btn btn-primary">{{ form.submit.label.text }}</button>
      </form>
    </div>
  </div>
  
</div>
{% endblock %}



